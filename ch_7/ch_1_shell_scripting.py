"""
В системе Linux не все процессы, команды которых просто вводятся в интерпретатор, будут выполняться.
И конечно, можно работать эффективнее, сгруппировав наборы часто используемых команд. Скрипты оболочки
как раз для этого и созданы

Скрипт оболочки — это группа команд, функций, переменных или почти все, что можно задействовать из оболочки.
Эти элементы помещаются в обычный текстовый файл, который затем можно запустить как команду. В Linux скрипты
оболочки традиционно используют для загрузки системы во время запуска, чтобы выполнять команды и запускать необходимые
службы. Пользователь может создавать собственные скрипты оболочки для автоматизации регулярных задач.

Десятилетиями создание скриптов оболочки было основным навыком, необходимым для объединения наборов задач в системах
UNIX и Linux. По мере того как требования к настройке систем Linux переставали быть требованиями к одной
системе и становились сложными конфигурациям автоматизированных кластеров, появились более структурированные методы.
Эти методы включают в себя Ansible playbooks и файлы Kubernetes YAML, описанные далее в главах, связанных с
облаком. Тем не менее написание скриптов оболочки — по-прежнему наилучший способ автоматизации повторяющихся задач
в системах Linux.

Скрипты оболочки
    Скрипты оболочки эквивалентны пакетным файлам в Windows и могут содержать длинные списки команд, сложное
    управление потоками, арифметические вычисления, пользовательские переменные и функции, а также сложную проверку
    условий. Скрипты оболочки способны обрабатывать все: от простых однострочных команд до чего-то столь же сложного,
    как запуск системы Linux. Хотя в Linux доступны десятки различных оболочек, используемая по умолчанию оболочка для
    большинства систем Linux называется bash (Bourne Again SHell)

Выполнение и отладка скриптов
    Одно из основных преимуществ скриптов оболочки — можно открыть их в любом текстовом редакторе и посмотреть
    содержимое. Серьезный недостаток — большие или сложные скрипты оболочки часто выполняются медленнее,
    чем скомпилированные программы. Скрипт оболочки выполняется двумя основными способами:
        * Имя файла используется в оболочке в качестве аргумента (как в bash myscript).
            В этом случае файл не обязательно должен быть исполняемым — он просто
            содержит список команд оболочки. Оболочка, указанная в командной строке,
            применяется для интерпретации команд в файле скрипта. Этим способом часто
            реализуют быстрые простые задачи
        * В первой строке скрипта оболочки может стоять имя интерпретатора, перед
            которым указаны символы #! (как в #!/bin/bash) и флаг исполнения файла
            с набором скриптов (реализуется с помощью chmod +x filename). Затем можно
            запустить свой скрипт так же, как и любую другую программу в пути, просто
            введя его имя в командной строке.

    При выполнении скриптов любым способом параметры программы можно
    указать в командной строке. Все, что следует за именем скрипта, называется аргументом командной строки

    Как и при написании любого ПО, нет никакой замены четкому, продуманному
    дизайну и большому количеству комментариев. Знак фунта (#) указывается перед
    комментарием и может занимать целую строку или стоять в строке после кода скрипта.
    Лучше всего реализовывать более сложные скрипты оболочки постепенно, убедившись, что на каждом этапе все
    работает логично. Вот несколько кратких советов, чтобы убедиться, что все работает так, как нужно:
        * В некоторых случаях можно поместить оператор echo в начале строки в теле
            цикла и взять его в кавычки. Таким образом вместо того, чтобы выполнять код,
            можно увидеть, что будет выполнено без внесения каких-либо изменений.
        * Для этой же цели можно разместить фиктивные операторы echo по всему коду.
            Если строки с ними появляются на экране, значит, логика соблюдается.
        * Используйте команду set -x в начале скрипта, чтобы отобразить каждую выполняемую команду или
            запустить скрипты с помощью:
                $ bash -x myscript
        * Полезные скрипты имеют тенденцию увеличиваться со временем, поэтому
            чрезвычайно важно сохранить код читаемым. Делайте все возможное, чтобы
            логика вашего кода оставалась стройной и понятной.

Переменные оболочки
    Имена переменных в скриптах оболочки чувствительны к регистру и могут быть определены следующим образом:
        ИМЯ=значение
    Первая часть переменной — это ее имя, а вторая — набор значений для него.
    Убедитесь, что ИМЯ и значение соединены знаком равенства без пробелов. Значениями переменных могут быть константы,
    такие как текст, цифры и символы подчеркивания. Это помогает инициализировать значения и экономить текст для
    записи длинных констант. В следующих примерах показаны переменные, заданные
    в виде строки символов (CITY) и числового значения (PI):
        CITY="Springfield"
        PI=3.14159265
    Переменные могут содержать выходные данные команды или последовательности команд. Для этого нужно поставить
    перед командой знак доллара и открыть скобку, а после нее набрать закрывающую скобку. Например, MYDATE=$(date)
    присваивает выходные данные команды date переменной MYDATE. То же самое получится, если добавить в команду
    обратные тики (`). В этом случае команда date выполняется при введении переменной, а не при каждом ее чтении

    Использование в оболочке специальных символов.
        Имейте в виду, что такие символы, как знак доллара ($), обратный тик (`), звездочка (*), восклицательный
        знак (!) и др., имеют особые значения в оболочке. В каких-то случаях они нужны, а в каких-то — нет.
        Например, если набрать echo $HOME, оболочка отобразит на экране имя домашнего каталога, хранящегося в
        переменной $HOME (например, /home/chris), так как символ $ указывает, что за ним следует имя
        переменной.

        Если в действительности нужно показать текст $HOME, то знак $ следует экранировать.
        Для этого введите echo'$HOME' или echo \$HOME. Поэтому, если нужно, чтобы оболочка интерпретировала
        один символ буквально, введите перед ним обратную косую черту(\). Чтобы интерпретировать все
        значение буквально, окружите эти символы одинарными кавычками(')

        С двойными кавычками все немного сложнее. Окружите набор текста двойными
        кавычками, если нужно, чтобы все символы, кроме некоторых, обрабатывались
        буквально. Например, если текст окружен двойными кавычками, знаки доллара ($),
        обратные тики (`) и восклицательные знаки (!) интерпретируются по-особенному,
        а другие символы (например, *) — как обычно. Введите следующие три строки, чтобы
        получить различные выходные данные (показаны справа):
            $ echo ' $HOME * ` date` ' => $HOME * `date`
            $ echo " $HOME * ` date` " => /home/user * Tue Jan 21:15:56 +5 2024
            $ echo $HOME * `date` => /home/user file.sh Tue Jan 21:15:56 +5 2024

    Переменные могут содержать также значения других переменных, что полезно,
    когда нужно сохранить изменяющееся значение и позже задействовать его в скрипте. В примере далее
    BALANCE устанавливается в значение переменной CurBalance:
        $ BALANCE="$curBalance"

Позиционные параметры оболочки.
    Существуют специальные переменные, которые назначает оболочка. Набор часто
    используемых символов называется позиционными параметрами аргументов
    командной строки. Они указываются в виде значений $0, $1, $2, $3... $n. $0 — особенный, ему
    присваивается имя, используемое для вызова скрипта, остальным присваиваются значения параметров,
    передаваемых в командной строке, в том порядке, в котором они появились.

    Предположим, что скрипт оболочки с именем myscript содержит:
        #!/bin/bash
        # Script to echo out command-line arguments
        echo "The first argument is $1, the second is $2."
        echo "The command itself is called $0."
        echo "There are $# parameters on your command line"
        echo "Here are all the arguments: $@"
    Как видно в примере, позиционный параметр $0 — это полный или относительный путь к myscript,
    $1 — к foo, а $2 — к bar.
    Другая переменная, $#, сообщает, сколько параметров было задано в скрипте.
    В этом примере переменная $# будет равна 2. Переменная $@ содержит все аргументы, введенные в командной
    строке. Другой специальной переменной оболочки является $?, которая получает статус выхода последней
    выполненной команды. Как правило, нулевое значение означает, что команда завершилась успешно, а все,
    что не равно нулю, указывает на ошибку. Полный список позиционных параметров оболочки см. в руководстве
    bash

Чтение параметров
    С помощью команды read можно запросить у пользователя информацию и сохранить ее для последующего
    использования в скрипте. Пример скрипта с командой read:
        #!/bin/bash
        read -p "Type in an adjective, noun and verb (past tense):" adj1 noun1 verb1
        echo "He sighed and $verb1 to the elixir. Then he ate the $adj1 $noun1."

Расширение параметров в bash
    Как уже упоминалось, если нужно получить значение переменной, перед ней
    следует указать знак $ (например, $CITY). На самом деле это просто сокращенное
    обозначение ${CITY}, фигурные скобки используются, когда значение параметра
    не должно отделяться от другого текста пробелом.

    У оболочки bash есть специальные правила, которые позволяют расширить
    значение переменной различными способами. Конечно, сразу все правила изучить
    нельзя, однако далее представлено несколько общих конструкций, которые встречаются в скриптах
    bash:
        * ${var:-значение} — если переменная не задана или пуста, расширяет до
            значения значение.(Грубо говоря, значение это дефолт для var)
        * ${var#шаблон} — удаляет кратчайшее совпадение шаблона шаблон от начала
            параметра var.
        * ${var##шаблон} — удаляет наибольшее совпадение шаблона шаблон с началом
            параметра var.
        * ${var%шаблон} — удаляет кратчайшее совпадение шаблона шаблон до конца
            параметра var
        * ${var%%шаблон} — удаляет наибольшее совпадение шаблона шаблон с концом
            параметра var
    Введите следующие команды из командной оболочки, чтобы проверить, как
    работает расширение параметров:
        $ THIS="Example"
        $ THIS=${THIS:-"DEFAULT FOR THIS"}
        $ THAT=${THAT:-"Default for THAT"}
        $ echo $THIS => Example
        $ echo $THAT => Default for THAT

    В следующем примере MYFILENAME имеет значение /home/digby/myfile.txt.
    Далее переменная FILE имеет значение myfile.txt, а DIR — значение /home/digby.
    В переменной NAME имя файла сокращается просто до myfile , а в переменной
    EXTENSION расширение файла устанавливается как txt. (Чтобы попрактиковаться,
    введите их в командной строке, как в предыдущем примере, и повторите значение
    каждой переменной, чтобы увидеть, в каком значении она установлена.) Введите
    код, приведенный слева, справа описано его действие:
        * MYFILENAME=/home/digby/myfile.txt — устанавливает значение MYFILENAME;
        * FILE=${MYFILENAME##*/} — FILE присваивается myfile.txt;
        * DIR=${MYFILENAME%/*} — DIR присваивается /home/digby;
        * NAME=${FILE%.*} — NAME присваивается myfile;
        * EXTENSION=${FILE##*.} — EXTENSION присваивается txt.

Арифметические операции в скриптах оболочки
    Bash использует нетипизированные переменные, то есть обрабатывает переменные
    как строки текста, что при желании можно быстро изменить

    Арифметика с целыми числами выполняется с помощью встроенной команды
    let, или внешних команд expr, или bc. После установки значения переменной
    BIGNUM равным 1024 все три следующие команды будут хранить значение 64
    в переменной RESULT. Команда bc — это приложение калькулятора, имеющееся
    в большинстве дистрибутивов Linux. Последняя команда получает случайное число
    в диапазоне от 0 до 10 и возвращает результаты:
        BIGNUM=1024
        let RESULT=$BIGNUM/16
        RESULT=`expr $BIGNUM / 16`
        RESULT=`echo "$BIGNUM / 16" | bc`
        let foo=$RANDOM; echo $foo

    Другой способ увеличения значения переменной — использовать $(()) с добавлением ++ для
    увеличения значения I. Введите:
        $ I=0
        $ echo "The value of I after increment is $((++I))" => The value of I after increment is 1
        $ echo "The value of I before and after increment is $((I++)) and $I" => The value of I before and
            after increment is 1 and 2

!!!ВНИМАНИЕ!!!
    Большинство элементов в скриптах оболочки имеют относительно свободную форму (где пробелы или отступы
    неважны), тогда как для команд let и expr интервалы особенно важны. Команда let требует, чтобы не было пробелов
    между каждым аргументом операции (операндом) и математическим оператором, в то время как синтаксис
    команды expr требует указания пробелов между каждым операндом и его оператором. В отличие от них команда
    bc не зависит от пробелов, но сама по себе сложнее, потому что выполняет вычисления с плавающей запятой

!!!ВНИМАНИЕ!!!
    Префиксные и постфиксные(++var/var++) операторы отличаются тем что префиксные операторы сначала увеличивают
    значение на 1 а потом возвращают значение, а постфиксные операторы возвращают старое значение а только потом
    увеличивают на 1
    Пример:
        Постфикс:
            x=5
            y=$((x++))
            echo x: $x => 6
            echo y: $y => 5
        Префикс:
            x=5
            y=$((++x))
            echo x: $x => 6
            echo y: $y => 6

Программные конструкции в скриптах оболочки
    Одна из особенностей, которая делает скрипты оболочки максимально полезными, заключается в том, что
    реализуются циклические и условные конструкции, аналогичные тем, которые встречаются в более сложных
    скриптах и языках программирования. Вы можете использовать несколько различных типов циклических
    конструкций в зависимости от своих потребностей.

    Конструкция if...then
        Первый вариант, if...then, проверяет, присвоено ли параметру VARIABLE значение 1. Если все верно,
        то команда echo отобразит результат. Затем оператор if указывает, что конструкция if завершена и
        обработка может быть продолжена:
            VARIABLE=1
            if [ $VARIABLE -eq 1 ] ; then
            echo "The variable is 1"
            fi

    Вместо -eq можно поставить знак равенства (=), как показано в следующем
    примере. Знак = лучше всего подходит для сравнения значений строк, в то время
    как с помощью eq удобнее сравнивать числа. С помощью оператора else можно повторять слова, если условие
    конструкции if не выполняется ($STRING = "Friday"). Имейте в виду, что строки нужно помещать в двойные кавычки:
        STRING="Friday"
        if [ $STRING = "Friday" ] ; then
        echo "WhooHoo. Friday."
        else
        echo "Will Friday ever get here?"
        fi

    В следующем примере конструкция elif (что означает else if) используется для
    проверки существования дополнительного условия (например, является filename
    файлом или каталогом):
        filename="$HOME"
        if [ -f "$filename" ] ; then
            echo "$filename is a regular file"
        elif [ -d "$filename" ] ; then
            echo "$filename is a directory"
        else
            echo "I have no idea what $filename is"
        fi
    Как видно из предыдущих примеров, тестируемое условие помещается в квадратные скобки []. Вычисление
    условия выдает или 0 (выражение истинно), или 1 (выражение ложно). Обратите внимание на то, что оператор
    echo отбивается отступами. Отступ необязателен и делается только для того, чтобы скрипт был более
    удобочитаемым.
    Полезные операторы проверки условий
        -a file - Файл существует? (-e проверяет то же)
        -b file - Является ли файл частью съемного устройства?
        -c file - Является ли символ специальным (например, символьным устройством)?
                    Используется для идентификации последовательных соединений
                    и терминальных устройств
        -d file - Это каталог?
        -e file - Файл существует? (-a проверяет то же)
        -f file - Существует ли этот файл и является ли он обычным файлом (например,
                    не каталогом, сокетом, каналом, ссылкой или файлом устройства)?
        -g file - Установлен ли в файле бит set group id (SGID)?
        -h file - Является ли этот файл символической ссылкой? (-L проверяет то же)
        -k file - Есть ли в файле набор sticky bit?
        -L file - Является ли этот файл символической ссылкой?
        -n string - Длина строки превышает 0 байт?
        -O file - Это ваш файл?
        -p file - Является ли файл именованным конвейером?
        -r file - Можете ли вы просматривать этот файл?
        -s file - Существует ли этот файл и больше ли он 0 байт?
        -S file - Существует ли этот файл и является ли он сокетом?
        -t fd - Подключен ли файловый дескриптор к терминалу?
        -u file - Установлен ли в файле бит set user id (SUID)?
        -w file - Можете ли вы переписывать этот файл?
        -x file - Можете ли вы выполнять этот файл?
        -z строка - Равна ли длина строки 0 (ноль)?
        expr1 -a expr2 - Верны ли и первое, и второе выражения?
        expr1 -o expr2 - Верно ли одно из этих двух выражений?
        file1 -nt file2 - Первый файл новее, чем второй (используется метка времени модификации)?
        file1 -ot file2 - Первый файл старше, чем второй (используется метка времени модификации)?
        file1 -ef file2 - Связаны ли эти два файла ссылкой (жесткой или символической)?
        var1 = var2 - Равна ли первая переменная второй?
        var1 -eq var2 - Равна ли первая переменная второй?
        var1 -ge var2 - Первая переменная больше второй переменной или равна ей?
        var1 -gt var2 - Больше ли первая переменная, чем вторая?
        var1 -le var2 - Первая переменная меньше второй переменной или равна ей?
        var1 -lt var2 - Первая переменная меньше второй?
        var1 != var2 - Не равна ли первая переменная второй переменной?
        var1 -ne var2 - Не равна ли первая переменная второй переменной?

    Существует также сокращенный метод проверки, полезный для простых однокомандных действий.
    В примере далее два конвейера (||) указывают, что если проверяемого каталога не существует (-d dirname),
    то нужно создать его (mkdir$$dirname)
        # [ check expr ] || action
        # Выполнить однокомандное действие, если тест неверен.
        dirname="/tmp/testdir"
        [ -d "$dirname" ] || mkdir "$dirname"

    Вместо конвейеров можно использовать два амперсанда и проверить выражение. В следующем примере проверяется,
    содержит ли команда по крайней мере три аргумента командной строки:
        # [ test ] && {action}
        # Выполнить однокомандное действие, если тест верен.
        [ $# -ge 3 ] && echo "There are at least 3 command line arguments."

    Можно комбинировать операторы && и ||, чтобы ускорить проверку с помощью
    if...then...else. В следующем примере проверяется, существует ли уже каталог
    $dirname. Если да, появится сообщение о том, что каталог существует. Если нет,
    конструкция создаст его:
        # dirname=mydirectory
        [ -e $dirname ] && echo $dirname already exists || mkdir $dirname

    Команда case
        Часто используется и конструкция с командой case. Подобно оператору switch
        в языках программирования, он может заменить несколько операторов if. Далее
        приводится общая форма выражения case:
            case "VAR" in
                Result1)
                    { body };;
                Result2)
                    { body };;
                *)
                    { body } ;;
            esac

        Помимо прочего, можно использовать команду case, чтобы разобраться с резервными копиями.
        Следующее выражение проверяет первые три буквы текущего
        дня (case 'date+%a' in). Затем в зависимости от дня недели устанавливаются
        определенный каталог резервных копий (BACKUP) и носитель (TAPE):
            # Значение VAR не обязательно должно быть переменной,
            # оно также может быть выводом команды.
            # Выполняйте действия в зависимости от дня недели
            case `date +%a` in
                "Mon")
                    BACKUP=/home/myproject/data0
                    TAPE=/dev/rft0
                ;;
                "Tue" | "Thu")
                    BACKUP=/home/myproject/data1
                    TAPE=/dev/rft1
                ;;
                "Wed" | "Fri")
                    BACKUP=/home/myproject/data2
                    TAPE=/dev/rft2
                ;;
                *)
                    BACKUP="none"
                    TAPE=/dev/null
                ;;
            esac
        Звездочка (*) используется в качестве ключевого слова, аналогичного слову
        default в языке программирования С. В этом примере, если ни одна из прочих записей не
        сопоставляется на пути вниз по циклу, это делает звездочка, и значение BACKUP становится none.
        Обратите внимание на esac (case наоборот) в завершении проверки выражения case.

    Цикл for...do
        Циклы применяются для реализации повторяющихся действий до тех пор, пока
        не будет выполнено условие выражения или не обработаны все данные. Чаще всего
        используется цикл for...do. Он перебирает список значений, выполняя тело цикла
        для каждого элемента в списке. Синтаксис цикла выглядит так:
            for VAR in LIST
            do
                { body }
            done
        Каждый элемент в LIST отделен от следующего пробелом. Будьте с этим осторожны, потому что некоторые
        команды, такие как ls -l выводят в строке несколько полей, каждое из которых отделено пробелом.
        Строка done завершает выражение for

        Заядлый программист на языке С может использовать его синтаксис для работы
        с циклами:
            LIMIT=10
            # Используются двойные скобки без знака $ в значении LIMIT,
            # несмотря на то что это переменная!
            for ((a=1; a <= LIMIT ; a++)) ; do
                echo "$a"
            done

    Циклы while...do и until...do
        Еще два популярных цикла — это while...do и until...do. Вот их структуры:
            while [ condition ]          until [ condition ]
            do                           do
                { body }                    { body }
            done                         done
        Оператор while выполняется, пока условие выражения истинно. Оператор until
        выполняется до тех пор, пока условие не станет истинным, другими словами, пока
        оно ложно.

Полезные программы для работы с текстом
    В оболочке bash есть множество полезных встроенных команд, однако для работы
    с ними обычно требуется помощь. Одни из самых популярных программ — это grep,
    cut, tr, awk и sed. Как и все лучшие инструменты UNIX, большинство этих программ
    предназначены для работы со стандартными вводом и выводом и позволяют использовать конвейеры и скрипты

Удаление части текста (команда cut)
    Команда cut извлекает поля из строки текста или файлов. Это полезно при разделении файлов конфигурации на
    легко читаемые и понятные фрагменты. Можно добавить разделитель полей или разбить строку на байты.

    В следующем примере перечислены все домашние каталоги пользователей в системе. Командная строка grep передает
    список обычных пользователей из файла /etc/passwd и отображает шестое поле (-f6),
    разделенное двоеточием (-d':')
    Дефис в конце дает команде cut инструкцию читать данные из стандартного ввода
    (из конвейера):
    $ grep /home /etc/passwd | cut  -d':' -f6 -
    /home/chris
    /home/joe
"""
