1. Имена переменных в скриптах оболочки чувствительны к регистру и могут быть определены следующим образом:
    ИМЯ=значение
    CITY="Springfield"
    PI=3.14159265
2. Если в действительности нужно показать текст $HOME, то знак $ следует экранировать.
    $ echo \$HOME => $HOME
    $ echo $HOME => /home/user
3. Окружите набор текста двойными кавычками, если нужно, чтобы все символы, кроме некоторых, обрабатывались
   буквально. Например, если текст окружен двойными кавычками, знаки доллара ($), обратные тики (`) и восклицательные
   знаки (!) интерпретируются по-особенному, а другие символы (например, *) — как обычно
    $ echo ' $HOME * ` date` ' => $HOME * `date`
    $ echo " $HOME * ` date` " => /home/user * Tue Jan 21:15:56 +5 2024
    $ echo $HOME * `date` => /home/user file.sh Tue Jan 21:15:56 +5 2024
4. Существуют специальные переменные, которые назначает оболочка. Они указываются в виде значений $0, $1, $2, $3... $n.
   $0 — особенный, ему присваивается имя, используемое для вызова скрипта(/file/path.sh)
    # Script to echo out command-line arguments
    echo "The first argument is $1, the second is $2."
    echo "The command itself is called $0."
    echo "There are $# parameters on your command line"
    echo "Here are all the arguments: $@"
5. С помощью команды read можно запросить у пользователя информацию и сохранить ее для последующего
   использования в скрипте.
    #!/bin/bash
    read -p "Type in an adjective, noun and verb (past tense):" adj1 noun1 verb1
    echo "He sighed and $verb1 to the elixir. Then he ate the $adj1 $noun1."
6. У оболочки bash есть специальные правила, которые позволяют расширить
   значение переменной различными способами. Конечно, сразу все правила изучить
   нельзя, однако далее представлено несколько общих конструкций, которые встречаются в скриптах
   bash:
    * ${var:-значение} — если переменная не задана или пуста, расширяет до значения значение.(Грубо говоря, значение это дефолт для var)
    * ${var#шаблон} — удаляет кратчайшее совпадение шаблона шаблон от начала параметра var.
    * ${var##шаблон} — удаляет наибольшее совпадение шаблона шаблон с началом параметра var.
    * ${var%шаблон} — удаляет кратчайшее совпадение шаблона шаблон до конца параметра var
    * ${var%%шаблон} — удаляет наибольшее совпадение шаблона шаблон с концом параметра var
7. Арифметические операторы
     x++/x-- => var += 1/var -= 1 как в python
     ++x/--x => check ch_1_shell_scripting.py 2nd attempt
     +/- - плюс/минус
     /* - деление/умножение
     **(^)/% - степень/корень
     >/</>=/<=/=/==/!=/ - операторы сравнения
8. Одни из способов выполнить арифметику в bash это команды let/expr/bc
    BIGNUM=1024
    let RESULT=$BIGNUM / 16
    let BIGGER="$BIGNUM * 10"
    let BIGGER="$BIGGER + 10"
    RESULT=`expr $BIGNUM / 16`
    RESULT=`echo "$BIGNUM / 16" | bc`
    let foo=$RANDOM; echo $foo
9. Другие способы выполнить арифметику
    RESULT=$[$var + $var2 * 20 / 20 % 5]
    echo "text: $[$var + 20 * 20 / 20 % 5]"
    echo $((1 + 2 - 3 * $var / 2))
    echo "text: $((1 + 2 - 3 * $var / 2))"
10. Вывод текста
    echo "It works with vars and other operators $var => var value"
    echo 'It doesnt work with vars or other special operators $var => text $var'
    echo "only command here -> `uname | grep txt`"
11. Операторы if/elif/else
    if [ expr ] ; then
        action
    elif [ expr ] ; then
        action
    else
        action
    fi
12. Полезные операторы проверки условий
    &&/||/! - and/or/not
    -a file - Файл существует? (-e проверяет то же)
    -b file - Является ли файл частью съемного устройства?
    -c file - Является ли символ специальным (например, символьным устройством)?
                Используется для идентификации последовательных соединений
                и терминальных устройств
    -d file - Это каталог?
    -e file - Файл существует? (-a проверяет то же)
    -f file - Существует ли этот файл и является ли он обычным файлом (например,
                не каталогом, сокетом, каналом, ссылкой или файлом устройства)?
    -g file - Установлен ли в файле бит set group id (SGID)?
    -h file - Является ли этот файл символической ссылкой? (-L проверяет то же)
    -k file - Есть ли в файле набор sticky bit?
    -L file - Является ли этот файл символической ссылкой?
    -n string - Длина строки превышает 0 байт?
    -O file - Это ваш файл?
    -p file - Является ли файл именованным конвейером?
    -r file - Можете ли вы просматривать этот файл?
    -s file - Существует ли этот файл и больше ли он 0 байт?
    -S file - Существует ли этот файл и является ли он сокетом?
    -t fd - Подключен ли файловый дескриптор к терминалу?
    -u file - Установлен ли в файле бит set user id (SUID)?
    -w file - Можете ли вы переписывать этот файл?
    -x file - Можете ли вы выполнять этот файл?
    -z строка - Равна ли длина строки 0 (ноль)?
    expr1 -a expr2 - Верны ли и первое, и второе выражения?
    expr1 -o expr2 - Верно ли одно из этих двух выражений?
    file1 -nt file2 - Первый файл новее, чем второй (используется метка времени модификации)?
    file1 -ot file2 - Первый файл старше, чем второй (используется метка времени модификации)?
    file1 -ef file2 - Связаны ли эти два файла ссылкой (жесткой или символической)?
    var1 = var2 - Равна ли первая переменная второй?
    var1 -eq var2 - Равна ли первая переменная второй?
    var1 -ge var2 - Первая переменная больше второй переменной или равна ей?
    var1 -gt var2 - Больше ли первая переменная, чем вторая?
    var1 -le var2 - Первая переменная меньше второй переменной или равна ей?
    var1 -lt var2 - Первая переменная меньше второй?
    var1 != var2 - Не равна ли первая переменная второй переменной?
    var1 -ne var2 - Не равна ли первая переменная второй переменной?
13. Сокращенный метод проверки(ТОЛЬКО ДЛЯ ПРОСТЫХ СЛУЧАЕВ)
    [ check expr ] || action - однокомандное действие которое выполняется если условие выдаёт 0
    [ check expr  ] && {action} - однокомандное действие которое выполняется если условие выдаёт 1
    [ check expr ] && action || action - микс вариант с && и ||
14. Аналог switch case
    case expression in
        Result1)
            { body };;
        Result2)
            { body };;
        *)
            { body };;
    esac
15. Цикл for
    1: Обычный вариант
        for VAR in LIST
            do
                { body }
            done
    2: 2й более чистый вариант
        for VAR in LIST ; do
            echo $NAME is my favorite Beatle
        done
    3: C-подобный синтаксис
        # Используются двойные скобки без знака $ в значении LIMIT,
        # несмотря на то что это переменная!
        for ((a=1; a <= LIMIT ; a++)) ; do
            echo "$a"
        done
16. Циклы while/do и until/do
    1: Оператор while выполняется, пока условие выражения истинно.
        while [ condition ]
        do
            { body }
        don
    2: Оператор until выполняется до тех пор, пока условие не станет истинным,
    другими словами, пока оно ложно.
        until [ condition ]
        do
            { body }
        done
