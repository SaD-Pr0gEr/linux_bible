"""
Linux не только многопользовательская, но и многозадачная операционная система.
Многозадачность означает, что много программ могут выполняться одновременно.
Экземпляр запущенной программы называется процессом. Linux позволяет перечислять запущенные
процессы, мониторить использование системы и прерывать (убивать) процессы по необходимости.

Что такое процесс
Процесс — это запущенный экземпляр команды. Например, в системе может быть
одна команда vi. Однако если с vi работают одновременно 15 пользователей, то
она представлена 15 различными запущенными процессами.
Процесс идентифицируется в системе с помощью так называемого идентификатора процесса (PID).
Этот PID уникален для текущей системы. Другими словами, ни один прочий процесс не может
использовать этот номер в качестве идентификатора процесса, пока первый процесс работает.
Однако после завершения первого процесса другой процесс может повторно задействовать это число.

!!!ПРИМЕЧАНИЕ!!!
Команды, отображающие информацию о запущенных процессах, получают бóльшую часть этой информации
в виде необработанных данных, хранящихся в файловой системе /proc. Каждый процесс хранит свою информацию в
подкаталоге /proc с именем идентификатора этого процесса. Часть необработанных данных можно просмотреть,
отобразив содержимое файлов в одном из этих каталогов (используя команды cat или less).

Перечисление процессов
    Команда ps — одна из первых и наиболее распространенных команд для перечисления процессов, запущенных в
    данный момент в системе. Linux-версия команды ps содержит множество параметров из устаревших систем UNIX и
    BSD, часть из которых конфликтуют и реализуются нестандартными способами. На справочной странице ps
    представлена информация об этих параметрах.

    Терминал tty1
    используется для входа в систему. Столбец STAT отображает статус процесса, указывая, запущен ли процесс(R)
    или находится в спящем режиме (S).
    В столбце STAT могут отображаться несколько значений. Например, знак плюс (+) указывает, что процесс связан
    с операциями, протекающими в обычном режиме.

    В столбце USER отображается имя пользователя, запустившего процесс. У каждого процесса есть номер, называемый
    идентификатором процесса, или PID. Задействуйте PID, если нужно убить процесс или отправить другой сигнал процессу.
    Столбцы CPU и MEM показывают процентное соотношение работы процессора и оперативной памяти, которые использует
    текущий процесс

    VSZ (виртуальный размер процесса) показывает размер процесса изображения (в килобайтах), а RSS (размер страниц памяти)
    — размер программы в памяти. Значения VSZ и RSS могут различаться, потому что VSZ — это объем памяти, выделенный для
    процесса, тогда как RSS — это объем, который используется фактически. RSS-память представляет собой физическую
    незаменяемую память.

    Столбец START показывает время начала выполнения процесса, а TIME — совокупное используемое системное время.
    (Большинство команд потребляет мало процессорного времени, для тех, которые не использовали ни секунды, время
    отражается как 0:00.)

    Многие запущенные на компьютере процессы не связаны с терминалом. Обычно в системе Linux множество процессов работает
    в фоновом режиме. Фоновые системные процессы выполняют различные задачи, к примеру измеряют активность системы или
    изучают данные из сети. Они часто запускаются при загрузке Linux и работают непрерывно, пока система не выключится.
    Аналогично вход на рабочий стол Linux запускает многие фоновые процессы, к примеру процессы управления аудио, панели
    рабочего стола, аутентификацию и другие функции рабочего стола

    Команда ps может отображать выбранные столбцы информации и сортировать
    информацию по одному из этих столбцов. Используя параметр -o, можно добавить
    ключевые слова для указания столбцов, которые нужно перечислить с помощью
    команды ps. Далее в примере отображаются все запущенные процессы (-e), а за
    ними следует параметр -o для каждого столбца, содержащего нужную информацию,
    включая идентификатор процесса (pid), имя пользователя (user), идентификатор
    пользователя (uid), название группы (group), идентификатор группы (gid), количество выделенной виртуальной
    памяти (vsz), количество резидентной памяти (rss) и запущенную командную строку (come).
        $ ps -eo pid,user,uid,group,gid,vsz,rss,comm | less

    Если нужно отсортировать данные иначе, примените параметр sort=. Например, чтобы увидеть,
    какие процессы используют больше всего памяти, я сортирую
    список по столбцу vsz от меньшего к большему. Поскольку мне сначала нужно
    увидеть самые затратные процессы, я поставил дефис перед параметром сортировки (sort=-vsz):
        $ ps -eo pid,user,group,gid,vsz,rss,comm --sort=-vsz | head

Перечисление и изменение процессов с помощью команды top
    Команда top показывает процессы, запущенные в системе. По умолчанию порядок
    их отображения зависит от того, сколько процессорного времени они потребляют
    в данный момент. Однако можно сортировать информацию и по другим столбцам.

    После того как будет найден неправильно работающий процесс, с помощью команды
    top можно его завершить (kill) или изменить его приоритет (renice)
    Чтобы завершать или переименовывать процессы, нужно запускать команду
    от имени суперпользователя. Чтобы просто отображать процессы и, возможно,
    завершать или изменять свои собственные, можно запускать команды и от имени
    обычного пользователя

    Общая информация о системе отображается в верхней части, а затем указываются сведения о
    каждом запущенном процессе (сколько поместится на экране). Сверху показано, как долго система
    работает, сколько пользователей в настоящее время вошли в нее и сколько было запросов за последние
    одну, пять и десять минут.

    Общая информация включает в себя данные о том, сколько процессов (задач)
    в настоящее время запущено, насколько активно задействован ЦП, сколько используется оперативной памяти
    и подкачки (swap). Далее приведены списки для каждого процесса, отсортированные по степени задействования
    ресурсов процессора. Вся эта информация по умолчанию обновляется каждые 5 секунд.

    Далее приведен список действий, которые можно выполнить с помощью команды top, чтобы отобразить информацию
    различными способами и изменить запущенные процессы:
        * Нажмите клавишу h, чтобы просмотреть параметры справки, а затем — любую
            клавишу, чтобы вернуться к основному дисплею.
        * Нажмите клавишу M, чтобы отсортировать информацию об использовании памяти, а затем — клавишу P,
            чтобы вернуться к сортировке по процессору.
        * Нажмите цифру 1, чтобы переключать отображение степени использования
            процессоров, если в системе их больше одного.
        * Нажмите клавишу R для обратной сортировки выходных данных.
        * Нажмите u и введите имя пользователя, чтобы увидеть только его процессы.

    Обычно команда top применяется для поиска процессов, которые потребляют
    слишком много памяти или вычислительной мощности, и взаимодействия с ними.
    У процесса, потребляющего слишком много ресурсов ЦП, можно сменить приоритет.
    Или завершить его (убить). Пример использования top:
        * Смена приоритета.
            Запомните идентификатор процесса, для которого нужно
            сменить приоритет, и, наберите команду renice с PID процесса.
            При появлении запроса Renice PID to value на изменение значения PID введите
            число от –20 до 19. (См. подраздел «Настройка приоритета с помощью команд
            nice и renice» далее в этой главе, чтобы узнать о значениях для renice.)
        * Убийство процесса.
            Запомните идентификатор процесса и нажмите клавишу k.
            Введите 15, чтобы процесс завершил работу, или 9, чтобы остановить его сразу.
            (Дополнительную информацию о различных сигналах, которые можно посылать процессам,
            см. в подразделе «Завершение процессов с помощью команд kill и killall» далее в этой главе.)

Управление обычными и фоновыми процессами.
    Существует несколько способов переведения активной программы в фоновый режим. Один из них — добавить амперсанд
    (&) в конец командной строки при первом запуске команды. Эту команду можно использовать, чтобы выполнять
    команды, не подключаясь к оболочке.
    Чтобы остановить запущенную команду и перевести ее в фоновый режим,
    нажмите сочетание клавиш Ctrl+Z. После того как команда остановлена, можно
    либо вернуть ее в обычный режим (команда fg), либо запустить в фоновом режиме (команда bg). Имейте в виду,
    что любая команда, работающая в фоновом режиме, может выдать выходные данные во время выполнения команд в обычном
    режиме. Например, если появляется вывод из команды, работающей в фоновом режиме во время сеанса vi, нажмите
    сочетание клавиш Ctrl+L, чтобы обновить экран и убрать вывод

    !!!ПРИМЕЧАНИЕ!!!
        Разница между ps и jobs в том, что ps показывает все процессы в системе, и это внешняя команда(а не builtin как
        jobs). В свою очередь jobs показывает только те процессы вызванные в рамках сессии с текущим терминалом(поэтому
        в других терминалах эти процессы не покажутся)

    Первое задание показывает команду редактирования текста (vi), которая приостановлена (с помощью сочетания клавиш
    Ctrl+Z) и находится в фоновом режиме. Задание 2 показывает только что запущенную команду find. Задания 3 и 4
    показывают команды nroff, работающие в данный момент в фоновом режиме. Задание 5 выполнялось в оболочке (в обычном
    режиме), пока я не решил, что запущено слишком много процессов, и не нажал Ctrl+Z, чтобы остановить его, пока не
    будут завершены другие процессы.
    Знак плюс (+) рядом с цифрой 5 показывает, что процесс совсем недавно переведен в фоновый режим. Знак минус
    (-) рядом с цифрой 4 показывает, что процесс был переведен в фоновый режим предпоследним. Поскольку задание
    1 требует ввода терминала, оно не может выполняться в фоновом режиме. В результате оно
    остановлено (Stopped) до тех пор, пока его не переведут в обычный режим.

    Чтобы увидеть идентификатор процесса для фонового задания, добавьте параметр -l (строчная буква L) в
    команду задания. Введите ps, чтобы с помощью идентификатора процесса выяснить, какая команда предназначена для
    конкретного фонового задания.

Команды для обычного и фонового режимов
    В том же примере можно вывести на передний план любую из команд, входящую в список заданий. Например, для
    того чтобы вернуть первый процесс обратно на передовой, нужно снова ввести:
        $ fg %1

    !!!ВНИМАНИЕ!!!
        Прежде чем перевести текстовый редактор или аналогичную программу в фоновый режим, убедитесь, что файл
        сохранен. Легко забыть о программе, работающей в фоновом режиме, выйти из системы и потерять данные.

    Чтобы вернуться к фоновому заданию (отменить его или перевести в обычный режим), используйте знак процента (%),
    после которого стоит номер задания. Для работы с фоновым процессом применяйте следующие команды:
        * %
            Относится к последней команде, помещенной в фоновый режим (обозначается знаком плюс при вводе команды jobs).
            Выводит команду на передний план
        * %string
            Относится к заданию, в котором команда начинается с определенной строки символов. Строка должна быть
            однозначной. (Другими словами, ввод %vi при наличии двух команд vi в фоновом режиме приводит к появлению
            сообщения об ошибке.)
        * %?string
            Относится к заданию, в котором командная строка содержит строку в любой точке. Строка должна быть
            однозначной, в ином случае совпадения не будет.
        * %--
            Относится к последнему остановленному процессу.

    Чтобы перевести процесс на фоновый режим также можно использовать команду bg. Можете ввести
        bg %2, чтобы перевести 2й процесс из списка jobs на фоновый режим

Завершение процессов и изменение их приоритетов
    Точно так же, как можно изменять поведение процесса с помощью графических
    инструментов, таких как System Monitor (описан ранее в этой главе), можно использовать средства командной строки,
    чтобы завершить процесс или изменить его приоритет. Команда kill посылает сигнал завершения любому процессу при
    условии, что у пользователя есть разрешение на это. Команда может также посылать различные сигналы процессу,
    чтобы изменить его поведение. Команды nice и renice применяются для настройки или изменения приоритета

    Завершение процессов с помощью команд kill и killall
        Обычно команды kill и killall применяются для завершения запущенного процесса, однако они могут отправлять
        запущенному процессу любую допустимую инструкцию. Помимо отправки сигнала завершения, команда может сообщить
        процессу о необходимости пересмотреть файлы конфигурации, приостановиться (остановиться) или продолжить
        выполнение после приостановки, и это еще не все варианты.

        Сигналы представляются как числами, так и именами. Чаще всего для команд
        используют сигналы SIGKILL (9), SIGTERM (15) и SIGHUP (1). Сигналом по умолчанию является SIGTERM,
        который аккуратно завершает процесс. Чтобы немедленно завершить процесс, задействуйте SIGKILL.
        Сигнал SIGHUP в зависимости от программы может сообщить процессу, чтобы он пересмотрел свои файлы конфигурации.
        SIGSTOP приостанавливает процесс, а SIGCONT продолжает остановленный процесс.
        Разные процессы по-разному реагируют на различные сигналы. Однако процессы не могут блокировать сигналы
        SIGKILL и SIGSTOP.

        Сигналы
            Название                 Номер                             Описание
            ____________________________________________________________________
            SIGHUP                    1                          Обнаружен обрыв связи с управляющим терминалом либо
                                                                    завершение управляющего процесса
            SIGINT                    2                          Прерывание с клавиатуры
            SIGQUIT                   3                          Выход с клавиатуры
            SIGABRT                   6                          Сигнал прерывания, посланный функцией abort(3)
            SIGKILL                   9                          Сигнал немедленного завершения
            SIGTERM                   15                         Сигнал завершения
            SIGCONT                   19, 18, 25                 Продолжить выполнение, если остановлен
            SIGSTOP                   17, 19, 23                 Приостановить выполнение процесса

        Обратите внимание на то, что для SIGCONT и SIGSTOP существует несколько возможных чисел, поскольку разные
        номера используются в разных компьютерных сборках. Для большинства сборок x86 и Power берите среднее значение.
        Первое значение обычно работает в Alpha и SPARC, а последнее — в MIPS.

Отправка сигналов с помощью kill по PID
    Вот как можно завершить процесс несколькими способами, используя идентификатор запущенного процесса
    bigcommand:
        $ kill 10432
        $ kill -15 10432
        $ kill -SIGKILL 10432

    По умолчанию сигнал, посылаемый командой kill, равен 15 (SIGTERM), поэтому у первых двух примеров результаты
    одинаковые. Иногда SIGTERM не может завершить процесс, поэтому понадобится сигнал SIGKILL, чтобы убить его.
    Вместо SIGKILL можно использовать -9 и получить тот же результат

    Полезен и сигнал SIGHUP. Если, например, на рабочем столе GNOME произошел сбой, отправьте в gnome-shell
    сигнал SIGHUP, чтобы перечитать его файлы конфигурации и перезапустить. Если бы идентификатор процесса для
    gnome-shell был 1833, то отправить ему сигнал SIGHUP можно было бы двумя способами:
        # kill -1 1833
        # killall -HUP gnome-shell

Отправка сигналов процессам с помощью killall по имени
    С помощью команды killall можно отправлять сигналы процессам, указывая их
    имена, а не идентификаторы. Преимущество этого приема в том, что в таком случае
    для завершения процесса идентификатор не нужен. Потенциальный недостаток
    заключается в том, что по неосторожности можно завершить больше процессов,
    чем нужно. (Например, набрав killall bash, можно завершить кучу оболочек, чего
    не стоило бы делать.)

Настройка приоритета с помощью команд nice и renice
    Когда ядро Linux решает, какие запущенные процессы получают доступ к процессорам, оно принимает во внимание и
    указанный для процесса приоритет. Каждый запущенный в системе процесс имеет приоритет в диапазоне от –20 до 19.
    По умолчанию устанавливается приоритет 0. Приведу сведения о приоритетах.
    * Чем ниже значение приоритета, тем процесс приоритетнее для процессора.
        Чем выше значение приоритета, тем меньше процессор «обращает внимания» на процесс. Таким образом,
        процесс со значением –20 приоритетнее для процессора, чем процесс со значением 19
    * Обычный пользователь может установить приоритет только от 0 до 19.
        Отрицательные значения ему недоступны. Таким образом, обычный пользователь
        не может устанавливать приоритет процессов выше, чем задано по умолчанию
    * Обычный пользователь может только увеличивать значения, но не уменьшать.
        Так, например, если пользователь установит значение приоритета 10, а затем
        захочет вернуться к значению 5, действие выполнено не будет. Любая попытка
        установить отрицательное значение также окажется неудачной.
    * Обычный пользователь может устанавливать приоритет только для
        собственных процессов.
    * Суперпользователю разрешено устанавливать приоритеты для любого процесса,
        и это может быть любое допустимое значение

    Используйте команду nice, чтобы установить приоритет процесса. Для изменения приоритета уже запущенного
    процесса задействуйте команду renice вместе с идентификатором процесса, как показано далее:
        # nice -n +5 updatedb &
    Команда updatedb применяется для принудительного создания базы данных
    путем сбора имен файлов по всей файловой системе. В примере мне было необходимо, чтобы процесс updatedb
    работал в фоновом режиме (&) и не прерывал работу, выполняемую другими процессами в системе.

    Обратите внимание на то, что в столбце Ni указан приоритет 5. Поскольку команда запущена от имени
    суперпользователя, позже значение приоритета можно уменьшить с помощью команды renice.
    (Помните, что обычный пользователь не может уменьшить значение приоритета и установить отрицательное
    число.) Так, можно изменить приоритет команды updatedb, задав значение -5:
        # renice -n -5 20284
    Снова запустив команду top, можно заметить, что команда updatedb теперь
    находится в верхней части списка процессов, потребляющих ЦП, благодаря установленному приоритету.

Ограничения для процессов с помощью cgroups.
    Используйте функцию установки приоритета, чтобы дать одному процессу больший или меньший доступ к
    процессорному времени. Однако значение приоритета процесса не применяется к его дочерним процессам или любым
    другим связанным процессам. Другими словами, приоритет не ограничивает общее количество ресурсов, которые
    конкретный пользователь или приложение может потреблять из системы Linux

    По мере развития облачных вычислений многие системы Linux будут работать
    скорее как гипервизоры, чем как компьютеры общего пользования. Их память,
    вычислительная мощность и доступ к хранилищу станут широко задействоваться
    множеством обычных пользователей. В таком случае необходимо иметь больше
    возможностей для управления объемом системных ресурсов, к которым имеют
    доступ конкретный пользователь, приложение, конвейер или виртуальная машина
    в системе Linux.

    Вот тут-то и появляются контрольные группы механизма cgroups.
    Данный механизм используется для идентификации процесса как задачи, принадлежащей определенной контрольной группе.
    Задачи могут быть выстроены в соответствии с иерархией, вверху которой может находиться, например, задача-демон,
    устанавливающая ограничения по умолчанию для всех процессов сервера демонов, а ниже — подзадачи, которые задают
    определенные ограничения для демона веб-сервера (httpd) и демона службы FTP (vsftpd)

    Поскольку задача запускает процесс, то процессы, начатые начальным процессом (их называют дочерними),
    имеют те же ограничения, что и родительский процесс. Ограничиваться может доступ к определенным процессорам
    или определенным наборам оперативной памяти. Можно также ограничить доступ к 30 %
    общей вычислительной мощности

    Типы ресурсов, которые могут быть ограничены механизмом cgroups, таковы.
    * Устройства (blkio) — устанавливает лимиты на доступ к запоминающим
        устройствам (жестким дискам, USB-накопителям и т. д.)
    * Процессор (cpu) — обеспечивает доступ процессов в рамках контрольной
        группы к CPU
    * Учет процессов (cpuacct) — генерирует отчеты об использовании ресурсов процессора.
        С помощью данной информации можно рассчитать, сколько клиенты
        должны будут заплатить за объем задействуемой ими вычислительной мощности
    * Распределение процессоров (cpuset) — при наличии нескольких процессорных
        ядер распределяет между ними задачи в рамках контрольной группы
    * Доступ к устройствам (devices) — разрешает или блокирует доступ (mknod)
        к выбранным устройствам.
    * Приостановка процесса (freezer) — приостанавливает и возобновляет
        выполнение задач в рамках контрольной группы
    * Использование памяти (memory) — управляет выделением памяти для групп
        процессов и создает отчеты об используемых ресурсах.
    * Пропускная способность сети (net_cls) — ограничивает доступ к сети для
        выбранных задач в рамках контрольной группы. Помечает сетевые пакеты
        специальной меткой, позволяя идентифицировать порождаемые определенной
        задачей в рамках контрольной группы
    * Сетевой трафик (net_prio) — используется для динамической установки приоритетов по трафику,
        позволяет администратору изменять приоритеты
    * Пространство имен (ns) — разделяет контрольные группы на пространства
        имен, причем для одной контрольной группы видны только связанные пространства имен.
        Пространства имен могут включать отдельные таблицы процессов, таблицы монтирования и сетевые интерфейсы.

    На базовом уровне создание контрольных групп и управление ими не является основной задачей системных
    администраторов Linux. Однако важно уметь
    редактировать файлы конфигурации и создавать контрольные группы (/etc/cgconfig.conf) или
    устанавливать ограничения для определенных пользователей либо групп (/etc/cgrules.conf).
    Для создания групп cgroups можно использовать также команду cgcreate, в результате эти группы будут
    добавлены в иерархию /sys/fs/cgroup. Настройка контрольных групп — задача непростая, и, если ее
    выполнить неправильно, система может перестать загружаться.

    Я рассказываю о группах потому, что необходимо понимать основные функции Linux, которые применяются для
    ограничения используемых ресурсов и мониторинга. В будущем вы, вероятно, столкнетесь с этими функциями
    у контроллеров облачной инфраструктуры. Вы сможете устанавливать правила, например «разрешать виртуальным
    машинам отдела маркетинга потреблять до 40% доступной памяти» или «привязать базу данных к определенному
    процессору и набору памяти».

    Знание того, как Linux может ограничивать использование ресурсов набором
    процессов, назначенных задаче, в конечном счете поможет лучше управлять вычислительными ресурсами.
    Чтобы узнать больше о контрольных группах, изучите следующие документы:
        * Руководство Red Hat Enterprise Linux Resource Management and Linux Containers,
        access.redhat.com/documentation/en-us/red_hat_Enterprise_linux/7/html-single/resource_management_ guide/index

        * Информация о контрольных группах на сайте Kernel. Перейдите к файлу
            /usr/share/doc/kernel-doc-*/Documentation/cgroups после установки пакета
            kernel-doc.
"""
